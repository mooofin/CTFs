![image](https://github.com/user-attachments/assets/7fe52968-6b17-4da1-bcdd-d3acc4e7c82c)
![image](https://github.com/user-attachments/assets/6e5d249f-5408-4257-b1fc-17ebd49e1c95)




To begin the PicoCTF challenge, I ran the vulnerable binary and noticed that it asked for input. Suspecting a buffer overflow vulnerability, I decided to test it by inputting a long cyclic pattern — a special sequence of characters designed to help identify how many bytes it takes to reach and overwrite a register. After generating a 300-byte pattern using `cyclic(300)` from the pwntools library, I ran the program again and pasted the pattern into the input. The program crashed with a segmentation fault, which was exactly what I was hoping for — a sign that I had overwritten something important in memory. I opened the binary in GDB (the debugger) and checked the values of the registers. I found that the `rbp` register held the value `0x6361617463616173`, which looked like part of my input pattern.




![image](https://github.com/user-attachments/assets/d262cc89-3dae-4cf4-a217-5a9d34601949)



After the program crashed, I used GDB to inspect the CPU registers to understand what part of memory had been affected by my input. I ran the `info registers` command, which displayed the current values of all the registers. What stood out was the `rbp` register — it held the value `0x6361617463616173`. 

![image](https://github.com/user-attachments/assets/7958e37d-67b3-4249-89f3-3ebdd3de2c0c)



I found that the `rbp` register had been overwritten with the value `0x6361617463616173`, which clearly came from the cyclic pattern I had input. To find the exact offset at which the overflow occurred, I used pwntools' `cyclic_find()` function and passed in the byte string `b'saacatcaa'`, which is the little-endian representation of the value from `rbp`. The tool correctly returned `272`, meaning that 272 bytes of input filled the buffer, and anything after that would overwrite `rbp` and eventually the return address.
![image](https://github.com/user-attachments/assets/31f98005-8a53-4ffd-8f11-a2bd299a0560)



Before I got the correct offset, I initially tried using `cyclic_find()` by directly passing the hex value from the `rbp` register like this: `cyclic_find(0x6361617463616173, n=8)`. However, this didn’t work as expected — instead of returning a small offset, it gave me a massive number like `246018052`, which didn’t make sense. The issue was that `cyclic_find()` expects a **byte string**, not a raw integer. When I passed the number directly, it interpreted it incorrectly. The fix was to either pack the hex value properly using `p64()` or — more reliably — just convert the value to its ASCII byte string form, `b'saacatcaa'`, and pass that to `cyclic_find()`. Once I did that, it correctly returned `272`, revealing the true overflow offset.

![image](https://github.com/user-attachments/assets/1a3553d8-5786-44d9-b34a-67e47ebf5080)

![image](https://github.com/user-attachments/assets/3965a2ed-2469-46c7-a25d-60e32d03632f)



