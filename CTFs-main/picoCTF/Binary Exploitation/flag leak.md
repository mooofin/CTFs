The provided C code contains a classic format string vulnerability within the `vuln()` function. Specifically, the `printf(story);` line is dangerous because it uses user-controlled input directly as the format string, without any sanitization or format specifier like `"%s"`. This allows an attacker to inject format specifiers such as `%x`, `%s`, or `%n`, which can lead to leaking memory contents, crashing the program, or even writing to memory. The input is collected using `scanf("%127s", story);`, which reads a string without spaces. An attacker could input something like `%x %x %x %x %x`, and the program would interpret it as format specifiers, printing out data from the stack. With enough experimentation, this can reveal valuable information such as the contents of variables, return addresses, or even the flag loaded into memory. In a typical CTF scenario, this would be exploited by identifying the correct offset on the stack, then using `%s` to leak a string from memory—potentially the flag—or `%n` to perform arbitrary writes.
![image](https://github.com/user-attachments/assets/96b6dce1-a4b8-4707-8523-415cf6784963)

When a program uses an unsafe `printf()` call—such as passing user input directly as the format string—it becomes vulnerable to a format string attack. Internally, `printf()` pulls its arguments from the stack, one by one, interpreting each based on the format specifiers given. By injecting a format string like `%x`, `%p`, or `%s`, an attacker can instruct `printf()` to interpret and print values from arbitrary positions on the stack. The `%x` specifier prints the raw hexadecimal value at a given stack position, while `%s` attempts to dereference the stack value as a pointer to a string and print the contents of that memory. To access specific stack positions directly, the syntax `%<index>$<specifier>` is used—e.g., `%7$s` prints the string pointed to by the 7th argument on the stack. 


In such vulnerabilities, a format specifier like `%x` lets you print raw data from the stack, treating it as a 4-byte value in hexadecimal. More interestingly, `%s` treats the value at the given stack location as a pointer to a string and tries to print that string. This makes it possible to leak sensitive memory values if a pointer to a flag or secret string exists anywhere on the stack. But `%s` needs the exact stack position, so I had to find the correct argument number where the flag buffer was located.

To automate this search, I wrote a Python script using `pwntools`. The script repeatedly connected to the remote service running on `saturn.picoctf.net` at port `64099`, and for each iteration, it sent a format string payload like `%1$s`, `%2$s`, ..., up to `%64$s`. Each payload asked the program to print the nth item on the stack as a string. After sending each payload, the script checked if the response contained the substring `CTF`, which would indicate a successful leak of the flag. This brute-force enumeration is often necessary in remote exploitation where you can't attach a debugger like `gdb` to inspect the stack directly.

Eventually, one of the payloads triggered the response:

```
[+] Opening connection to saturn.picoctf.net on port 64099: Done
b"Here's a story - \nCTF{L34k1ng_Fl4g_0ff_St4ck_95f60617}\n"
```
![image](https://github.com/user-attachments/assets/b9643519-6482-445a-b684-5ec8dde7c8b5)

