In this challenge, we exploit a classic signed 32-bit integer overflow in C. A 32-bit signed integer can store values between âˆ’2,147,483,648 and 2,147,483,647. When we add two positive integers that exceed this maximum limit, the result wraps around and becomes negative due to overflow. This behavior is not caught by the C language, which allows signed integer overflow as undefined behavior. The code specifically checks for this condition using the logic: if both inputs are positive and their sum is negative, an overflow has occurred. The minimal and most reliable way to trigger this is by using the values `2147483647` (which is `INT_MAX`) and `1`, since their sum becomes `-2147483648` (i.e., `INT_MIN`) due to the overflow. This satisfies the condition `a > 0 && b > 0 && result < 0` and allows us to retrieve the flag. Any larger input would either not be valid or wrap around improperly during input parsing, so only this specific pair of values consistently triggers the overflow in the intended way.
