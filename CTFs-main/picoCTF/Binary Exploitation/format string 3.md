The source code contains the following segment in `main()`:

```c
fgets(buf, 1024, stdin);
printf(buf);
puts(normal_string);
```

The `printf(buf);` line is vulnerable because it allows user input to be interpreted as a format string. If a user enters format specifiers (e.g., `%x`, `%n`), they will be processed by `printf`, potentially allowing reading from or writing to arbitrary memory locations.

Proper usage should specify a format explicitly:

```c
printf("%s", buf);
```

This confirms a format string vulnerability.

---

### Step 2: Identifying the Exploit Target

Immediately following the vulnerable `printf`, the program executes:

```c
puts(normal_string);
```

Here, `normal_string` is defined as:

```c
char *normal_string = "/bin/sh";
```

The goal is to manipulate this `puts("/bin/sh")` call so that it instead invokes `system("/bin/sh")`, effectively spawning a shell. This can be achieved by overwriting the GOT entry for `puts` with the address of `system`.

---

### Step 3: Address Leak

Earlier in the program, the `hello()` function provides a leak:

```c
printf("Here's the address of setvbuf in libc: %p\n", &setvbuf);
```

This leak is critical for bypassing ASLR. By knowing the runtime address of `setvbuf`, and the static offset of `setvbuf` within libc, it is possible to calculate the base address of the loaded libc. Once the libc base is known, the absolute address of `system()` can be computed using its known offset.

---


    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE (0x3ff000)
    RUNPATH:    b'.'
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No


Here's your write-up continued and refined in a technical tone, picking up from where you left off:

---

## Address Randomization and the Need for pwntools Automation

As expected, the address of the libc function `setvbuf()` changed on each execution. This behavior is a result of **PIE (Position Independent Executable)** being enabled for `libc.so.6`, as confirmed using `checksec`:

```bash
checksec libc.so.6
```

### Output:

```
Arch:     amd64-64-little  
RELRO:    Full RELRO  
Stack:    Canary found  
NX:       NX enabled  
PIE:      PIE enabled  
SHSTK:    Enabled  
IBT:      Enabled
```

Due to PIE and ASLR, the base address of libc is randomized each time the binary is executed. Therefore, the runtime address of `setvbuf()` cannot be hardcoded or predicted. To calculate the address of `system()`, a dynamic leak must be used to first resolve the libc base.

This randomization makes it impractical to construct the payload statically ahead of time—particularly when using simple shell input or piping from the terminal or a webshell. 

The **Procedure Linkage Table (PLT)** and the **Global Offset Table (GOT)** are key components in the implementation of dynamic linking in ELF (Executable and Linkable Format) binaries, which are commonly used on Linux systems. When a C program is compiled to use shared libraries (like libc), the actual memory addresses of external functions (e.g., `printf`, `puts`, `system`) are not known at compile time. Instead, the compiler generates references to these functions through PLT and GOT structures, which defer the resolution of addresses until runtime.

The **PLT** is a table of stubs (short sequences of instructions) that act as intermediaries for calling external functions. When a function is called, execution first jumps to its corresponding PLT entry. This PLT stub then looks up the real function address in the GOT and transfers control to it. If the function has not been called yet, the PLT entry invokes the dynamic linker, which resolves the function's address, updates the GOT entry, and then jumps to the resolved function.

The **GOT** is essentially a table in memory that stores the addresses of global symbols, including functions and variables. Initially, function entries in the GOT may point back to the PLT so that the dynamic linker can resolve them. Once resolved, the GOT is updated with the actual function address, and future calls via the PLT will directly use this resolved address. From an exploitation perspective, especially when a format string vulnerability is available, attackers can target the GOT by overwriting specific entries to redirect program execution to arbitrary or malicious locations, such as a different function like `system()` or custom shellcode.


```c
#include <stdio.h>

#define MAX_STRINGS 32

char *normal_string = "/bin/sh";

void setup() {
	setvbuf(stdin, NULL, _IONBF, 0);
	setvbuf(stdout, NULL, _IONBF, 0);
	setvbuf(stderr, NULL, _IONBF, 0);
}

void hello() {
	puts("Howdy gamers!");
	printf("Okay I'll be nice. Here's the address of setvbuf in libc: %p\n", &setvbuf);
}

int main() {
	char *all_strings[MAX_STRINGS] = {NULL};
	char buf[1024] = {'\0'};

	setup();
	hello();	

	fgets(buf, 1024, stdin);	
	printf(buf);

	puts(normal_string);

	return 0;
}
```
<img width="937" height="156" alt="image" src="https://github.com/user-attachments/assets/bd2e8ad3-0f2e-42f5-ab5e-35e549a16733" />

The binary actually  reveals the address of setvbuf in libc, which allows us to calculate the base address of libc at runtime despite ASLR. It then reads user input with fgets and prints it using printf(buf), introducing a format string vulnerability. This flaw allows arbitrary memory writes. Lastly, the program calls puts("/bin/sh"). By overwriting the GOT entry for puts with the address of system(), the call effectively becomes system("/bin/sh"), resulting in a shell being spawned. (hopefully :p) 

Also 
```printf("Okay I'll be nice. Here's the address of setvbuf in libc: %p\n", &setvbuf);```
This is the line that leaks the adress , without this it's very hard to find the adress to start with , this is an example of arbitary memory writes using format string 
<img width="993" height="733" alt="image" src="https://github.com/user-attachments/assets/24801931-ce7d-4c6a-8e6b-81e5d4141473" />

works : ) as it reads and gives us a pointer 

Also 

<img width="935" height="131" alt="image" src="https://github.com/user-attachments/assets/9e0d7cb7-1eb8-4622-b603-3eb2cabd88af" />

We get a segmentation fault , this means that we have access over where the strings are written at 
<img width="976" height="186" alt="image" src="https://github.com/user-attachments/assets/8bfedc13-93ee-4361-9664-85a0f1485cfa" />

So the general idea now is : 
Fetch the address of our setvbuf function in the libc library(These offsets never change inside that specific libc version. They’re relative to the start of the library in memory)
From this address, calculate the base address of libc ig
Send a format string payload that overwrrites it in GOt table 

Now we need to  find out the GOT entry address of the standard libc function puts() to overwrite this address with the address of system()
using gbd 

<img width="1487" height="741" alt="image" src="https://github.com/user-attachments/assets/c7c89c65-59b6-4dab-a6d5-8ccc5a36748d" />

<img width="1193" height="842" alt="image" src="https://github.com/user-attachments/assets/0c24b65e-1363-4ed1-872a-c8ae6c442fd2" />


Tbh i had a bit of confusion here as to find out which one should call the entry to GOT 

However this line stood out 
```
0x00000000004012f2 <+175>:   call   0x401080 <puts@plt>
```
The PLT entry at 0x401080 doesn't call the real puts() directly. Instead, it does the following:

Reads the actual address of puts from the GOT

Calls that address

So, effectively:

puts@plt → uses an indirect call through puts@got



So i need to overwrite the GOT entry for puts (i.e., puts@got) with the address of another function like system()



Moving onto dissasembling the plt 
```
(gdb) disas  0x401080
Dump of assembler code for function puts@plt:
   0x0000000000401080 <+0>:     endbr64
   0x0000000000401084 <+4>:     bnd jmp *0x2f8d(%rip)        # 0x404018 <puts@got.plt>
   0x000000000040108b <+11>:    nopl   0x0(%rax,%rax,1)
End of assembler dump.
(gdb)
```

Good thing the binary has no PIE or ASLR enabled otherwise the adress would change 


```
(gdb) x/gx &setvbuf
0x7ffff7e5a3f0 <setvbuf>:       0x55415641fa1e0ff3
(gdb) x/gx &system
0x7ffff7e2f760 <system>:        0x74ff8548fa1e0ff3
(gdb)

```

Because the adress changes each time on execution we can't really hardcode a value onto the function to overwrite but another lazy way to tackle this is to find out the difference between system() and setvbuf() . A more techincal explanation would be even with PIE enabled, the relative offset between functions inside libc will still be same '


By subtracting the `system()` address from the `setvbuf()` address:

```
0x7fc6926263f0 (setvbuf)
- 0x7fc6925fb760 (system)
= 0x2cac0 (offset between them)
```

This offset (`0x2cac0`) stays the same across runs (as long as the same libc is used), so now I can always compute:

```python
system_address = leaked_setvbuf - 0x2cac0
```

This should be the runtime adress difference 



































<img width="800" height="480" alt="image" src="https://github.com/user-attachments/assets/05ebdf9a-d85f-4145-985c-fde9f7515eaa" />











<img width="1915" height="974" alt="image" src="https://github.com/user-attachments/assets/5b7c97f4-81dd-4e8c-b21c-1e9a31654285" />

Reference - https://nuc13us.wordpress.com/2015/12/25/hack-using-global-offset-table/


