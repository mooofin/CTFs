In this challenge, I encountered a classic format string vulnerability where user input was passed directly to `printf()` without a format string — specifically, the code used `printf(buf);`. This allowed me to inject format specifiers like `%p`, `%s`, and `%n` to interact with memory on the stack. The `%p` specifier is used to print the value of a pointer in hexadecimal, which is useful for leaking memory addresses and stack contents. The `%n` specifier is more dangerous; it tells `printf` to write the number of bytes printed so far into a memory address provided on the stack — meaning it can be used for arbitrary memory writes if I control the pointed-to location.

To exploit the bug, I started by sending a payload with a series of `%p` specifiers to leak values from the stack:

```
%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,...
```

From the output, I noticed several of the leaked values resembled ASCII strings when interpreted as little-endian 64-bit values. For example, `0x7b4654436f636970` becomes `picoCTF{` when the bytes are reversed (`0x70 69 63 6f 43 54 46 7b`) and decoded as ASCII. I continued this for four more values, each time reversing the byte order and converting to ASCII. This gave me the remaining parts of the flag in sequence.

After putting everything together, I reconstructed the full flag:

```
picoCTF{4n1m41_57y13_4x4_f14g_5e67bcb4}
```
![image](https://github.com/user-attachments/assets/e4cd26ce-cebb-476f-8737-9be62a1c0e27)

![image](https://github.com/user-attachments/assets/00e0ce7b-b848-4f2a-9fae-89b78954de80)
