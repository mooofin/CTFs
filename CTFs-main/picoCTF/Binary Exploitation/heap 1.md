![image](https://github.com/user-attachments/assets/647f89ee-91be-46ca-8dd6-ac9ccf5590ec)


This challenge demonstrates a classic heap overflow vulnerability where insufficient bounds checking in the `scanf("%s", input_data)` call allows writing beyond the allocated 5-byte buffer. By analyzing the heap layout, we see that writing 12 bytes ("pico" + 4 padding bytes + "pico") reliably overwrites the adjacent `safe_var` variable due to their contiguous memory allocation. The first "pico" fills the legitimate buffer space, while the second "pico" precisely overwrites `safe_var` after accounting for heap metadata alignment. When the program later verifies `safe_var` using `strcmp()`, our injected "pico" string passes the check, triggering the win condition. This exploit works because: 1) the unbounded read corrupts adjacent memory without crashing, 2) we control the exact overflow distance, and 3) string comparisons in C continue until null termination. The solution highlights fundamental memory safety issues - proper bounds checking or using safer alternatives like `fgets()` would prevent this exploit. M
