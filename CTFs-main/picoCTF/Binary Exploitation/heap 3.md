

The binary provided a menu interface that allowed heap-related operations such as allocating an object, printing its data, freeing it, and checking for a win condition. Based on the options and the function labels like `x->flag`, it was clear that the object being managed had a `flag` field that needed to be set to `"pico"` in order to win. The binary also displayed a message on startup hinting at a use-after-free (UAF) vulnerability, suggesting that memory which had been freed was still being reused or accessed.


![image](https://github.com/user-attachments/assets/e01bc422-8cce-4730-92c6-8589f9e3ce78)


After allocating an object using the menu, we noticed that the program accepted user input for the `flag` field but didnâ€™t perform any bounds checking on it. This implied a classic heap overflow vulnerability: writing beyond the intended memory region. Since freed memory was being reused, it meant that with careful crafting, the program would allow us to reallocate previously used chunks and overwrite sensitive data fields, such as the `flag`.
![image](https://github.com/user-attachments/assets/d93295af-a9b2-40e1-9dff-e86d17f14d72)


To reliably perform the overwrite, we needed to know the exact number of bytes required to reach the vulnerable memory location. For this, a De Bruijn sequence was generated using the `pwntools` function `cyclic(100)`. This sequence contains every possible 4-character substring uniquely, allowing us to pinpoint the offset of an overwrite. After inputting this pattern as the flag and printing the heap contents, we identified the overwritten value (`"aaia"`). Using `cyclic_find(b"aaia")`, we found that the overflow started precisely at byte offset 30.
![image](https://github.com/user-attachments/assets/b0a54966-f3b6-411a-b9bf-4a70fc83ab96)



With the offset known, we constructed a payload of 30 bytes of filler followed by the string `"pico"`. This ensured that when the memory was overwritten, the `flag` field of the object would now contain the exact string needed to pass the win condition. The payload looked like this: `aaaabaaacaaadaaaeaaafaaagaaahaaapico`.

Before inputting this payload, we first freed the object using the menu option for `free`. Then, we reallocated a new object of at least 34 bytes and supplied the crafted payload. This reallocation reused the same memory region, and our input successfully overwrote the original flag field.

Finally, choosing the menu option to check the flag caused the program to call `strcmp(x->flag, "pico")`, which now returned true. The program responded with a win message: `YOU WIN!!11!!`, confirming the success of the heap overflow and use-after-free exploit. This challenge was an elegant demonstration of how heap memory can be manipulated through precise overflow control and memory reuse, commonly seen in real-world heap exploitation.

```[muffin@ACERNITO-15 SIDDHARTH U]$ python3 -c "from pwn import *; print(cyclic(30) + b'pico')"
b'aaaabaaacaaadaaaeaaafaaagaaahapico'
[muffin@ACERNITO-15 SIDDHARTH U]$ nc tethys.picoctf.net 54212

freed but still in use
now memory untracked
do you smell the bug?

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 5

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 2
Size of object allocation: 30
Data for flag: aaaabaaacaaadaaaeaaafaaagaaahapico

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 3


x = pico


1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 4
YOU WIN!!11!!
picoCTF{now_thats_free_real_estate_a11cf359}
```
