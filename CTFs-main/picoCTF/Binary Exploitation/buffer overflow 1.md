

I began by analyzing a 32-bit ELF binary named `vuln`, provided in a PicoCTF challenge. Using the `file` command, I confirmed that it was an Intel i386 executable, dynamically linked, and intended for Linux systems. When I ran the binary, it prompted me to enter a string and then printed a message like “Jumping to 0xXXXXXXXX.” This behavior immediately suggested a classic buffer overflow scenario, where user input is being used to overwrite and control the return address of a function.

To understand how the binary worked, I examined the provided source code. The vulnerable function defined a local buffer of 32 bytes using `char buf[32]`, and took user input with the unsafe `gets()` function. Since `gets()` doesn’t do bounds checking, I realized I could overflow the buffer and potentially overwrite the return address on the stack. My goal became clear: overwrite the return address with the address of a function called `win()` that prints the flag.

To find out exactly how many bytes of input were needed to reach the return address, I used the `cyclic()` function from the `pwntools` library. This function generates a unique pattern of bytes. I generated 100 bytes of cyclic pattern using a Python one-liner: `python3 -c "from pwn import *; print(cyclic(100))"`. I pasted this pattern into the program when prompted. The binary crashed and printed something like “Jumping to 0x6161616c”, which I recognized as part of the pattern. I then used `cyclic_find()` — specifically `python3 -c "from pwn import *; print(cyclic_find(0x6161616c))"` — to determine that the return address was exactly 44 bytes into my input.

Along the way, I faced a few environment issues, like accidentally naming my Python script `pwn.py`, which conflicted with the `pwntools` module. I also encountered a problem due to a `code.py` file in my Windows directory, which interfered with Python’s standard library. After renaming or removing those files, I was able to import `pwntools` properly and continue. Once I confirmed that 44 bytes filled the buffer and reached the return address, I was ready to construct my final payload: 44 bytes of padding followed by the address of the `win()` function, encoded in little-endian format.

![image](https://github.com/user-attachments/assets/79774edd-c4b4-45ab-9005-d0d1b919b027)
Certainly! Here's a paragraph describing how you found the address of the `win()` function using GDB, written in first person:


To find the address of the `win()` function, I used GDB, the GNU Debugger. I started by launching the binary inside GDB using the command `gdb ./vuln`. Once inside the debugger, I typed `info functions` to list all the available functions in the binary. This showed me a list of symbols, including one called `win`, along with its memory address. From the output, I saw that the address of `win` was `0x080491f6`. This is the exact address I needed to overwrite the return pointer with, so that when the function returns, it jumps straight to `win()` and executes the code to print the flag.


![image](https://github.com/user-attachments/assets/39490645-80e9-479e-884e-40903d383b76)


When I tried exploiting the remote service using `nc`, I pasted the payload directly into the terminal: 44 "A"s followed by the address of the `win()` function written as `\xf6\x91\x04\x08`. However, this didn’t work — the program printed “Jumping to 0x3666785c,” which was clearly not the correct address. I realized that netcat only sends plain text, so when I typed `\xf6\x91\x04\x08`, it was sending those literal characters, not the raw byte values needed to overwrite the return address correctly. To fix this, I wrote a short Python script using `pwntools` that connects to the remote server and sends the payload as raw bytes. The script used `b"A"*44 + p32(0x080491f6)` to craft the payload, then sent it with `sendline()` over the socket. This approach worked because it correctly packed the address in little-endian format and delivered it as binary, allowing the exploit to succeed and redirect execution to the `win()` function.


![image](https://github.com/user-attachments/assets/ed80687c-ae37-4522-b661-0776a24c78a1)





