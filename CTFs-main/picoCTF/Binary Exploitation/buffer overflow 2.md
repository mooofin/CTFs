![image](https://github.com/user-attachments/assets/d5d54f44-8111-44d9-9cd8-8d26577f9c14)

As I started digging into the source code, it didn’t take long to spot the vulnerability. The `vuln()` function was using the notorious `gets()` function — which is well known for being unsafe because it doesn’t do any bounds checking. That means if I enter more than 100 characters, I can overflow the buffer and overwrite other things on the stack — like the return address. That’s exactly what makes this program exploitable.

Now, hidden in the code is a function called `win()`. It’s never called directly in the program, but it’s clearly meant to print the flag. The catch is that it only does this if it receives two very specific arguments: `0xCAFEF00D` and `0xF00DF00D`. If either one doesn’t match, the function just exits without doing anything. So, to get the flag, I’ll not only have to overflow the buffer and hijack the return address, I’ll also need to pass in those two values as arguments.

To figure out exactly where the buffer overflow hits, I ran the binary inside `gdb` and sent a cyclic pattern — a special string that helps identify where in the input the crash happens. After the program crashed, I looked at the `eip` register using `info registers`, and saw that it contained `0x62616164`. That was part of the pattern I had sent in, which meant I had successfully overwritten the instruction pointer!

Next, I used `cyclic_find` with that value to figure out the precise offset — basically, how many bytes I need to send before I get control of `eip`. With that offset in hand, I was ready to build a payload that would jump into the `win()` function and try to give it the exact arguments it needed to spit out the flag.


![image](https://github.com/user-attachments/assets/538c2148-9cf8-4253-8f15-5bc7b4c9d136)



![image](https://github.com/user-attachments/assets/fee1331f-e14d-4b15-a9bc-a1e85a18335f)
```python
from pwn import *

context.binary = ELF('./vuln')
context.log_level = 'info'

p = remote('saturn.picoctf.net', 63531)

win = 0x08049296
offset = 112
ret = b'B'*4
arg1 = p32(0xCAFEF00D)
arg2 = p32(0xF00DF00D)

payload  = b'A' * offset
payload += p32(win)
payload += ret
payload += arg1
payload += arg2

p.sendlineafter(b"Please enter your string:", payload)
p.interactive()
```
To build the exploit, I crafted a payload designed to overwrite the return address on the stack and redirect execution to the hidden `win()` function. First, I added 112 bytes of padding (`b'A' * 112`) to fill the buffer exactly up to the saved return address — this was the offset I had calculated earlier using a cyclic pattern. Then, I appended the 4-byte little-endian address of the `win()` function using `p32()`, which ensured that when the vulnerable function returns, it jumps directly to `win()`. After that, I inserted 4 junk bytes (`b'BBBB'`) as a fake return address for `win()`, since every function expects one even if we don't care where it returns. Finally, I pushed the two required arguments that `win()` checks before printing the flag — `0xCAFEF00D` and `0xF00DF00D` — also packed in little-endian format. With this carefully structured payload, I effectively faked a call to `win()` with the correct arguments and triggered it purely through a stack-based buffer overflow.

![image](https://github.com/user-attachments/assets/5b6784f2-a140-40a9-bb7b-409b39a0afc6)
