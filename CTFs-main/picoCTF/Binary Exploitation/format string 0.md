

We’re given two files:

* A **source code** file
* A compiled **binary**

The challenge hints at format string vulnerabilities:

> “Can you use your knowledge of format strings to make the customers happy?”

Let’s see how we can leverage this vulnerability to reach the final stage and retrieve the flag.

---

### Source Code Overview

Here’s a snippet of the key parts of the source code:

```c
#define BUFSIZE 32
#define FLAGSIZE 64
char flag[FLAGSIZE];

void sigsegv_handler(int sig) {
    printf("\n%s\n", flag);
    fflush(stdout);
    exit(1);
}

int on_menu(char *burger, char *menu[], int count) {
    for (int i = 0; i < count; i++) {
        if (strcmp(burger, menu[i]) == 0)
            return 1;
    }
    return 0;
}

void serve_patrick();
void serve_bob();

int main() {
    FILE *f = fopen("flag.txt", "r");
    if (f == NULL) {
        printf("Please create 'flag.txt' in this directory with your own debugging flag.\n");
        exit(0);
    }
    fgets(flag, FLAGSIZE, f);
    signal(SIGSEGV, sigsegv_handler);
    serve_patrick();
    return 0;
}
```

The **main()** function reads the flag and sets a signal handler for **SIGSEGV** that prints the flag and exits. This means if we can trigger a segmentation fault, we’ll get the flag printed!

---

### First Stage: serve\_patrick()

Here’s the core logic for Patrick:

```c
void serve_patrick() {
    printf("Welcome to our newly-opened burger place Pico 'n Patty!\n...");
    char choice1[BUFSIZE];
    scanf("%s", choice1);
    char *menu1[3] = {"Breakf@st_Burger", "Gr%114d_Cheese", "Bac0n_D3luxe"};
    if (!on_menu(choice1, menu1, 3)) {
        printf("There is no such burger yet!\n");
    } else {
        int count = printf(choice1);
        if (count > 2 * BUFSIZE) {
            serve_bob();
        } else {
            printf("Patrick is still hungry!\nTry to serve him something of larger size!\n");
        }
    }
}
```

Here’s what’s happening:
✅ We input a burger name.
✅ If it’s in the menu, it’s printed using **printf(choice1)**.
✅ The length of the output is counted using **int count = printf(choice1);**
✅ If this count exceeds 64 (2 × 32), we move on to **serve\_bob()**.

---

#### Why “Gr%114d\_Cheese” Works

Among the menu options, only `"Gr%114d_Cheese"` uses a **format specifier**:

```
%114d
```

This tells printf to print an integer (**d**) with a width of 114 characters. Since no argument is provided, printf will print garbage data (or spaces), inflating the count beyond 64 and satisfying the **if (count > 2 \* BUFSIZE)** condition.

Thus, to progress to Bob’s stage, input:

```
Gr%114d_Cheese
```

---

### Second Stage: serve\_bob()

Here’s what Bob’s stage looks like:

```c
void serve_bob() {
    printf("Good job! Patrick is happy!\n...");
    char choice2[BUFSIZE];
    scanf("%s", choice2);
    char *menu2[3] = {"Pe%to_Portobello", "$outhwest_Burger", "Cla%sic_Che%s%steak"};
    if (!on_menu(choice2, menu2, 3)) {
        printf("There is no such burger yet!\n");
    } else {
        printf(choice2);
        fflush(stdout);
    }
}
```

This stage also involves format strings.
Notably, `"Cla%sic_Che%s%steak"` contains multiple **%s** format specifiers. Since no corresponding arguments are provided to printf, it tries to access memory addresses off the stack, potentially triggering a segmentation fault.

Triggering this segmentation fault will invoke the **sigsegv\_handler**, which prints the flag!

---

#### Triggering the Exploit

Here’s the step-by-step to exploit the program and retrieve the flag:

First Input:

```
Gr%114d_Cheese
```

 Second Input:

```
Cla%sic_Che%s%steak
```

The second input triggers the segmentation fault (because of the multiple %s and missing arguments), which executes the handler:

```c
void sigsegv_handler(int sig) {
    printf("\n%s\n", flag);
    exit(1);
}
```

The flag is printed, and you’ve completed the challenge!

---

### Key Takeaways

 **Format String Vulnerabilities** can be exploited to read arbitrary memory or trigger crashes.
 Proper **input validation** and avoiding user-controlled format strings (like `printf(user_input)` without specifying a format string) are crucial to prevent these issues.
 This challenge was a great exercise in analyzing C source code and understanding the interplay between format strings and stack memory.

---

### Final Exploit Summary

```plaintext
Input 1: Gr%114d_Cheese
Input 2: Cla%sic_Che%s%steak
Flag revealed via segmentation fault!
```

---

![image](https://github.com/user-attachments/assets/9c7a42b2-5522-4651-afe5-d6df733abd5c)

