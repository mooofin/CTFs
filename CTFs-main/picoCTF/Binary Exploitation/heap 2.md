

The program allocates two buffers on the heap: `input_data` and `x`, both with a size of 5 bytes. It initializes `input_data` with the string `"pico"` and `x` with `"bico"`. The vulnerability arises from the `write_buffer()` function, which uses `scanf("%s", input_data)` without bounds checking. This allows a heap overflow—writing beyond the 5-byte allocation of `input_data` and into the memory space of `x`.
<img width="1919" height="803" alt="image" src="https://github.com/user-attachments/assets/ef9d5bce-8b74-42e8-aa43-442af25305d3" />

The `check_win()` function treats the contents of `x` as a function pointer. It dereferences the value at `x`, casts it to a function, and then calls it. If the attacker can overwrite the bytes at `x` with the address of a valid function—specifically, the `win()` function—then invoking `check_win()` will jump to that address and execute it.

To find the address of `win()`, the binary is loaded into GDB and disassembled. The `disassemble win` command shows that the function begins at address `0x4011a0`. This is the target address to inject into memory.
<img width="1149" height="425" alt="image" src="https://github.com/user-attachments/assets/f31695d2-ce47-430d-84b3-5458da73aa3c" />

Since `x` is located directly after `input_data` on the heap, an input to `input_data` that is longer than 5 bytes will overflow into `x`. By carefully crafting this overflow, one can replace the beginning of `x` with the little-endian encoding of the target address.

Using GDB, the address of the `win()` function is determined to be `0x4011a0`. This is the desired target for redirection. The payload consists of a sequence of padding bytes to overflow `input_data` followed by the little-endian encoding of the `win()` address. In the exploit script, 32 bytes of padding are used:

```python
payload = b"A" * 32
payload += p64(0x4011a0)
```

This input is sent to the program through option 2 (write to buffer). The 32-byte overflow ensures that the address at `x` is overwritten with the value `0x4011a0`. When option 4 is selected (triggering `check_win()`), the program dereferences the new value at `x` and jumps to `win()`. The function `win()` opens `flag.txt`, reads its contents, and prints them to stdout, completing the exploit.

<img width="1891" height="488" alt="image" src="https://github.com/user-attachments/assets/5768f2f4-92ce-49d8-862b-ca0c78a627ed" />

The payload used 

<img width="1908" height="889" alt="image" src="https://github.com/user-attachments/assets/41b3ab03-27a3-433d-ab67-eaa82a1a5e16" />
