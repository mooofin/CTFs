

The program allocates two buffers on the heap: `input_data` and `x`, both with a size of 5 bytes. It initializes `input_data` with the string `"pico"` and `x` with `"bico"`. The vulnerability arises from the `write_buffer()` function, which uses `scanf("%s", input_data)` without bounds checking. This allows a heap overflow—writing beyond the 5-byte allocation of `input_data` and into the memory space of `x`.
<img width="1919" height="803" alt="image" src="https://github.com/user-attachments/assets/ef9d5bce-8b74-42e8-aa43-442af25305d3" />

The `check_win()` function treats the contents of `x` as a function pointer. It dereferences the value at `x`, casts it to a function, and then calls it. If the attacker can overwrite the bytes at `x` with the address of a valid function—specifically, the `win()` function—then invoking `check_win()` will jump to that address and execute it.

To find the address of `win()`, the binary is loaded into GDB and disassembled. The `disassemble win` command shows that the function begins at address `0x4011a0`. This is the target address to inject into memory.
<img width="1149" height="425" alt="image" src="https://github.com/user-attachments/assets/f31695d2-ce47-430d-84b3-5458da73aa3c" />

Since `x` is located directly after `input_data` on the heap, an input to `input_data` that is longer than 5 bytes will overflow into `x`. By carefully crafting this overflow, one can replace the beginning of `x` with the little-endian encoding of the target address.

