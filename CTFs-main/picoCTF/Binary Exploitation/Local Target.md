```c
#include <stdio.h>
#include <stdlib.h>



int main(){
  FILE *fptr;
  char c;

  char input[16];
  int num = 64;

  printf("Enter a string: ");
  fflush(stdout);
  gets(input);
  printf("\n");

  printf("num is %d\n", num);
  fflush(stdout);

  if( num == 65 ){
    printf("You win!\n");
    fflush(stdout);
    // Open file
    fptr = fopen("flag.txt", "r");
    if (fptr == NULL)
    {
        printf("Cannot open file.\n");
        fflush(stdout);
        exit(0);
    }

    // Read contents from file
    c = fgetc(fptr);
    while (c != EOF)
    {
        printf ("%c", c);
        c = fgetc(fptr);
    }
    fflush(stdout);

    printf("\n");
    fflush(stdout);
    fclose(fptr);
    exit(0);
  }

  printf("Bye!\n");
  fflush(stdout);
}
```


The provided C code contains a classic **stack-based buffer overflow** vulnerability. The vulnerability lies in the use of the unsafe `gets()` function, which does not perform bounds checking when reading user input into the 16-byte `input` buffer. This means that if we input more than 16 characters, we can overwrite adjacent memory on the stack—including the `num` variable, which is initialized as `64`. The program checks if `num == 65`, and if true, it opens and prints the contents of `flag.txt`.





To identify the exact offset where our overflow begins to modify `num`, I used a cyclic pattern generated with `pwntools`. By inputting this pattern into the program and observing the resulting crash, I was able to inspect the value of `num`. In one run, `num` became the integer `1633771879`, which matched a position in the cyclic pattern. I used `cyclic_find(1633771879)` to compute the offset at which `num` is overwritten. The result was `24`, meaning the overflow starts affecting `num` after 24 bytes.

![image](https://github.com/user-attachments/assets/38ce1569-270d-4954-b596-a67fab11d117)




With the offset determined, I crafted the exploit. Since the goal was to set `num` to `65` (so that the condition `if(num == 65)` becomes true), I constructed a payload consisting of 24 filler bytes (`b"A" * 24`) followed by the 4-byte representation of the integer `65`. Because we’re working on a little-endian 32-bit system, I used `p32(65)` to ensure the value is properly packed for memory.
![image](https://github.com/user-attachments/assets/0074966b-ecf5-49d7-9d23-608343d63a12)



Once the payload was ready, I set up a script to connect to the remote challenge at `saturn.picoctf.net` on port `55103`. I used `pwntools`' `remote()` function to establish the connection and then sent the payload using `sendlineafter()`, which waits for the “Enter a string:” prompt before submitting input. After sending the payload, I used `recvall()` to retrieve the full response from the server.
![image](https://github.com/user-attachments/assets/db115244-a952-4ac9-b2af-19d5654bc714)



Upon sending the crafted payload, the program overwrote the `num` variable with the value `65`, passed the condition in the `if` statement, and successfully opened `flag.txt`. As expected, the contents of the flag file were printed to the screen. This confirmed that the exploit worked exactly as intended.
