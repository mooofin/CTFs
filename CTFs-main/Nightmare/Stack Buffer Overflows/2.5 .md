Primary target is the **return address**. When a function in a program finishes, it needs to know where to go next. The return address acts like a bookmark, telling the CPU which instruction to execute after the function is complete. If we can use a buffer overflow to change this bookmark, we can control where the program goes, effectively hijacking its execution.

To find this vulnerability, we used the GDB (GNU Debugger). By running the program inside the debugger, we could pause it and inspect its memory. We set a breakpoint right after the program read our input. Using the `info frame` command, GDB showed us a map of the program's current memory space, revealing two critical locations:
1.  The starting address of our input buffer.
2.  The address where the return address was stored.



### **Building the Exploit**

Once we discovered the offset, the next phase was to write a script to automate the attack. For this, we used a powerful Python library called `pwntools`, which is designed for exploit development. The script performs the attack in a few clear steps.

First, the script starts the program and reads its initial output. The target program helpfully prints the memory location of the input buffer. Our script captures this address and saves it, as we will need it for the final step of the payload.

Next, the script constructs the malicious payload in three distinct parts. This payload is the string of data we will send to the program to trigger the exploit.

1.  **The Shellcode:** The first part of the payload is the shellcode. This is not text, but a small sequence of raw machine instructions. Its sole purpose is to open a command shell (`/bin/sh`) when the CPU executes it. This is the weapon of our exploit.

2.  **The Padding:** The second part is padding. Our shellcode is not exactly 40 bytes long, so we cannot just place the return address immediately after it. We need to fill the remaining space to ensure our payload is the correct length. The script calculates the precise amount of padding needed (`40 - length of the shellcode`) and adds that many junk characters. This acts as a delivery system, ensuring the final part of our payload lands in the exact right spot.

3.  **The New Return Address:** The final part of the payload is the new return address itself. Here, we take the buffer address that the script saved earlier and append it to the payload. We use a special `pwntools` function, `p64()`, to format this address into the 8-byte structure that a 64-bit system understands. This action overwrites the program's original bookmark with a new one that points right back to the start of our input bufferâ€”where our shellcode is waiting.

