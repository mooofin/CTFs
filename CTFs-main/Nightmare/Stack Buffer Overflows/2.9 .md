The `file` command output indicates the target is a **64-bit ELF executable** that is **statically linked**. The static linkage implies that all necessary library functions are contained within the binary itself, providing a large address space from which to source ROP gadgets.

The `pwn checksec` output details the enabled security mechanisms:

  * **RELRO:** Partial RELRO
  * **Stack:** No canary found
  * **NX:** NX enabled
  * **PIE:** No PIE (0x400000)

The relevant findings are:

  * **No Stack Canary:** The absence of a stack canary means a buffer overflow can overwrite the saved return pointer without being detected.
  * **No PIE:** Address Space Layout Randomization is not enabled for the main executable. Code segments will be loaded at a fixed base address (0x400000), making gadget addresses predictable and constant.
  * **NX Enabled:** The stack is marked as non-executable. This is the primary mitigation and prevents the execution of shellcode injected onto the stack. Therefore, a Return-Oriented Programming (ROP) exploit is required.

-----



Analysis of the decompiled C code from Ghidra reveals the program's logic and the location of the vulnerability.

The program prompts for a `numberCalcs` value between 4 and 255. It then allocates a heap buffer of size `numberCalcs * 4` via `malloc`. The vulnerability exists in option 5, "Save and Exit".

```c
if (calcChoice == 5) {
  memcpy(vulnBuf, calculations, (long)(numberCalcs << 2));
  free(calculations);
  return 0;
}
```

The flaw is a classic buffer overflow. The `memcpy` function copies data from the heap-allocated `calculations` buffer into `vulnBuf`, a fixed-size 40-byte buffer on the stack. There is no bounds check to ensure the size of the data being copied does not exceed the capacity of `vulnBuf`. By specifying a `numberCalcs` value greater than 10, the resulting copy operation will exceed the 40-byte limit and overwrite adjacent data on the stack, including the saved return pointer.

-----



The next step is to determine the exact offset in bytes from the start of `vulnBuf` to the saved return pointer. This is achieved through dynamic analysis with `gef`.

A breakpoint is set at `0x40154a`, immediately following the `memcpy` instruction. The program is executed with `numberCalcs` set to `50` to ensure a significant overflow. A single calculation is performed (`159 + 321456789`) to place a unique marker, `0x13290b34`, onto the heap, which is then copied to the stack.

Upon hitting the breakpoint, the stack is inspected:

  * The start of the overflowed buffer, `vulnBuf`, is identified by locating the marker `0x13290b34`. Its address is **`0x00007fffffffde60`**.
  * The `info frame` (`i f`) command is used to identify the location of the saved return pointer (`rip`). Its address is **`0x00007fffffffdea8`**.

The offset is calculated by subtracting the start address of the buffer from the address of the saved return pointer:
`0x7fffffffdea8 - 0x7fffffffde60 = 0x48`

The offset is **`0x48`**, or **72 bytes**. Since each calculation result is a 4-byte integer, this corresponds to `72 / 4 = 18` integers of padding required to reach the return address.

-----



With control over the instruction pointer, the objective is to execute a new shell via the `execve("/bin/sh", NULL, NULL)` system call. On x86-64, this requires setting specific registers to the correct values before invoking the `syscall` instruction.

| Register | Required Value | Purpose |
| :--- | :--- | :--- |
| `rax` | `0x3b` | Syscall number for `execve`. |
| `rdi` | Pointer to "/bin/sh" | First argument: file to execute. |
| `rsi` | `0x0` | Second argument: `argv` (none). |
| `rdx` | `0x0` | Third argument: `envp` (none). |

A ROP chain will be constructed to achieve this. The chain will consist of a sequence of memory addresses pointing to gadgets within the binary. The payload will be structured as follows:

1.  **Padding:** 72 bytes (18 integers) to fill the buffer up to the saved return address.
2.  **ROP Chain:** A sequence of gadget addresses to:
      * Write the string `/bin/sh` into a known, writable memory location.
      * Load the address of that string into the `rdi` register using a `pop rdi; ret` gadget.
      * Load `0x0` into the `rsi` register using a `pop rsi; ret` gadget.
      * Load `0x0` into the `rdx` register using a `pop rdx; ret` gadget.
      * Load `0x3b` into the `rax` register using a `pop rax; ret` gadget.
      * Execute a `syscall` gadget to trigger the system call.

The subsequent task is to use a tool such as `ROPgadget` to find the memory addresses of these required instruction snippets within the statically linked binary.
